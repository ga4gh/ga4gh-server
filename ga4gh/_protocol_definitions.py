"""
DO NOT EDIT THIS FILE!!
This file is automatically generated by the process_schemas.py program
in the scripts directory. It is not intended to be edited directly. If
you need to update the GA4GH protocol classes, please run the script
on the appropriate schema version.
"""
from protocol import ProtocolElement
from protocol import SearchRequest
from protocol import SearchResponse

import avro.schema

version = '.6.1'


class Allele(ProtocolElement):
    """
    `Allele`s are the key component of the "allelic" model of
    variation: they are single objects that are present in some copy
    number.  An `Allele` is a contiguous piece of sequence that we
    will want to say is present (in general at some copy number) or
    absent in a sample. Very often it will just be a single `Segment`
    covering the entirety of a novel `Sequence`, but it is also common
    for it to be a mix of `Segment`s on reference and novel
    `Sequence`s, or in general to be any contiguous path through the
    augmented sequence graph.  `Allele`s belong to `VariantSet`s.
    `Allele`s can also be used to represent the reference and
    alternate alleles of `Variant`s.  Note that `Path`s cannot follow
    `Join`s not represented in the augmented sequence graph. For
    example, if  an `Allele` that spans a novel deletion is required,
    a new `Join` should exist to describe that deletion, available
    through `searchJoins()`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Allele",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": "string", "name": "variantSetId"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "Path", "fields": [{"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"Segment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "start"}, {"doc": "", "type": "long", "name":
"length"}]}, "type": "array"}, "name": "segments"}]}, "name":
"path"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "path",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'path': Path,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'path': Path,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'path', 'variantSetId'
    ]

    def __init__(self):
        self.id = None
        self.path = None
        self.variantSetId = None


class AlleleCall(ProtocolElement):
    """
    An `AlleleCall` represents the determination of the copy number of
    a particular `Allele`, possibly within a certain `Variant`.  It
    may include associated information such as quality and phasing.
    The `Allele` copy numbers described by an `AlleleCall` must be
    consistent with those implied by the `genotype`s of any `Call`s in
    the same `CallSet`. If a server supports "graph" mode, it must
    provide `Variant`-associated `AlleleCall`s for any `Variant` with
    a `Call` in the `CallSet`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"AlleleCall", "fields": [{"doc": "", "type": "string", "name":
"callSetId"}, {"doc": "", "type": "string", "name": "alleleId"},
{"doc": "", "type": ["null", "string"], "name": "variantId"}, {"doc":
"", "type": "double", "name": "totalCopies"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "phaseset"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "alleleId",
        "callSetId",
        "phaseset",
        "totalCopies",
        "variantId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alleleId', 'callSetId', 'info', 'phaseset', 'totalCopies',
        'variantId'
    ]

    def __init__(self):
        self.alleleId = None
        self.callSetId = None
        self.info = {}
        self.phaseset = None
        self.totalCopies = None
        self.variantId = None


class Analysis(ProtocolElement):
    """
    An analysis contains an interpretation of one or several
    experiments. (e.g. SNVs, copy number variations, methylation
    status) together with information about the methodology used.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Analysis", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "type"}, {"default": [], "doc":
"", "type": {"items": "string", "type": "array"}, "name": "software"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'description', 'id', 'info', 'name', 'software',
        'type', 'updated'
    ]

    def __init__(self):
        self.created = None
        self.description = None
        self.id = None
        self.info = {}
        self.name = None
        self.software = []
        self.type = None
        self.updated = None


class Attributes(ProtocolElement):
    """
    Type defining a collection of attributes associated with various
    protocol   records.  Each attribute is a name that maps to an
    array of one or more   values.  Values can be strings, external
    identifiers, or ontology terms.   Values should be split into the
    array elements instead of using a separator   syntax that needs to
    parsed.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Attributes", "fields": [{"default": {}, "type": {"values": {"items":
["string", {"doc": "", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}]}, {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}]}], "type": "array"}, "type": "map"}, "name": "vals"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'vals'
    ]

    def __init__(self):
        self.vals = {}


class BeaconInformationResource(ProtocolElement):
    """
    BeaconInformationResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"BeaconInformationResource", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"doc": "", "type": "string", "name": "organization"},
{"doc": "", "type": "string", "name": "description"}, {"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"DataSetResource", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "reference"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "DataSizeResource", "fields": [{"doc": "", "type":
"int", "name": "variants"}, {"doc": "", "type": "int", "name":
"samples"}]}], "name": "size"}, {"doc": "", "type": "boolean", "name":
"multiple"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "datasets"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name":
"DataUseResource", "fields": [{"doc": "", "type": "string", "name":
"category"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "DataUseRequirementResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]},
"type": "array"}, "name": "requirements"}]}, "type": "array"}, "name":
"data_use"}]}, "type": "array"}, "name": "datasets"}, {"doc": "",
"type": "string", "name": "api"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "homepage"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "email"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "auth"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "queries"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "api",
        "description",
        "id",
        "organization",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': DataSetResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': DataSetResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'api', 'auth', 'datasets', 'description', 'email', 'homepage',
        'id', 'organization', 'queries'
    ]

    def __init__(self):
        self.api = None
        self.auth = None
        self.datasets = []
        self.description = None
        self.email = None
        self.homepage = None
        self.id = None
        self.organization = None
        self.queries = None


class BeaconResponseResource(ProtocolElement):
    """
    The response from the Beacon
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"BeaconResponseResource", "fields": [{"doc": "", "type": "string",
"name": "beacon"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "QueryResource", "fields": [{"doc": "", "type": "string",
"name": "referenceBases"}, {"doc": "", "type": "string", "name":
"alternateBases"}, {"doc": "", "type": "string", "name":
"chromosome"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": "string", "name": "reference"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "dataset"}]}, "name":
"query"}, {"doc": "", "type": {"doc": "", "type": "record", "name":
"ResponseResource", "fields": [{"doc": "", "type": "string", "name":
"exists"}, {"doc": "", "type": ["null", "double"], "name":
"frequency"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "observed"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "info"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "ErrorResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"description"}]}], "name": "err"}]}, "name": "response"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "beacon",
        "query",
        "response",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'query': QueryResource,
            'response': ResponseResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'query': QueryResource,
            'response': ResponseResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'beacon', 'query', 'response'
    ]

    def __init__(self):
        self.beacon = None
        self.query = None
        self.response = None


class Call(ProtocolElement):
    """
    A `Call` represents the determination of genotype with respect to
    a particular `Variant`.  It may include associated information
    such as quality and phasing. For example, a call might assign a
    probability of 0.32 to the occurrence of a SNP named rs1234 in a
    call set with the name NA12345.  The genotypes described by
    `Call`s must be consistent with any `AlleleCall`s in the same
    `CallSet`. If a server supports "classic" mode, it must provide
    `Call`s for all `Variant`s that have associated `AlleleCall`s in
    the `CallSet`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Call",
"fields": [{"doc": "", "type": ["null", "string"], "name":
"callSetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "callSetName"}, {"doc": "", "type": ["null", "string"],
"name": "variantId"}, {"default": [], "doc": "", "type": {"items":
"int", "type": "array"}, "name": "genotype"}, {"default": null, "doc":
"", "type": ["null", "string", {"items": "string", "type": "array"}],
"name": "phaseset"}, {"default": [], "doc": "", "type": {"items":
"double", "type": "array"}, "name": "genotypeLikelihood"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "callSetId",
        "variantId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetId', 'callSetName', 'genotype', 'genotypeLikelihood',
        'info', 'phaseset', 'variantId'
    ]

    def __init__(self):
        self.callSetId = None
        self.callSetName = None
        self.genotype = []
        self.genotypeLikelihood = []
        self.info = {}
        self.phaseset = None
        self.variantId = None


class CallSet(ProtocolElement):
    """
    A `CallSet` is a collection of variant calls for a particular
    sample. It belongs to a `VariantSet`. This is equivalent to one
    column in VCF.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "CallSet",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"}, {"doc":
"", "type": ["null", "string"], "name": "sampleId"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"variantSetIds"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'id', 'info', 'name', 'sampleId', 'updated',
        'variantSetIds'
    ]

    def __init__(self):
        self.created = None
        self.id = None
        self.info = {}
        self.name = None
        self.sampleId = None
        self.updated = None
        self.variantSetIds = []


class CigarOperation(object):
    """
    An enum for the different types of CIGAR alignment operations that
    exist. Used wherever CIGAR alignments are used. The different
    enumerated values have the following usage:  * `ALIGNMENT_MATCH`:
    An alignment match indicates that a sequence can be   aligned to
    the reference without evidence of an INDEL. Unlike the
    `SEQUENCE_MATCH` and `SEQUENCE_MISMATCH` operators, the
    `ALIGNMENT_MATCH`   operator does not indicate whether the
    reference and read sequences are an   exact match. This operator
    is equivalent to SAM's `M`. * `INSERT`: The insert operator
    indicates that the read contains evidence of   bases being
    inserted into the reference. This operator is equivalent to
    SAM's `I`. * `DELETE`: The delete operator indicates that the read
    contains evidence of   bases being deleted from the reference.
    This operator is equivalent to   SAM's `D`. * `SKIP`: The skip
    operator indicates that this read skips a long segment of   the
    reference, but the bases have not been deleted. This operator is
    commonly used when working with RNA-seq data, where reads may skip
    long   segments of the reference between exons. This operator is
    equivalent to   SAM's 'N'. * `CLIP_SOFT`: The soft clip operator
    indicates that bases at the start/end   of a read have not been
    considered during alignment. This may occur if the   majority of a
    read maps, except for low quality bases at the start/end of   a
    read. This operator is equivalent to SAM's 'S'. Bases that are
    soft clipped   will still be stored in the read. * `CLIP_HARD`:
    The hard clip operator indicates that bases at the start/end of
    a read have been omitted from this alignment. This may occur if
    this linear   alignment is part of a chimeric alignment, or if the
    read has been trimmed   (e.g., during error correction, or to trim
    poly-A tails for RNA-seq). This   operator is equivalent to SAM's
    'H'. * `PAD`: The pad operator indicates that there is padding in
    an alignment.   This operator is equivalent to SAM's 'P'. *
    `SEQUENCE_MATCH`: This operator indicates that this portion of the
    aligned   sequence exactly matches the reference (e.g., all bases
    are equal to the   reference bases). This operator is equivalent
    to SAM's '='. * `SEQUENCE_MISMATCH`: This operator indicates that
    this portion of the   aligned sequence is an alignment match to
    the reference, but a sequence   mismatch (e.g., the bases are not
    equal to the reference). This can   indicate a SNP or a read
    error. This operator is equivalent to SAM's 'X'.
    """
    ALIGNMENT_MATCH = "ALIGNMENT_MATCH"
    INSERT = "INSERT"
    DELETE = "DELETE"
    SKIP = "SKIP"
    CLIP_SOFT = "CLIP_SOFT"
    CLIP_HARD = "CLIP_HARD"
    PAD = "PAD"
    SEQUENCE_MATCH = "SEQUENCE_MATCH"
    SEQUENCE_MISMATCH = "SEQUENCE_MISMATCH"


class CigarUnit(ProtocolElement):
    """
    A structure for an instance of a CIGAR operation.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"CigarUnit", "fields": [{"doc": "", "type": {"symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT",
"CLIP_HARD", "PAD", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "",
"type": "enum", "name": "CigarOperation"}, "name": "operation"},
{"doc": "", "type": "long", "name": "operationLength"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"referenceSequence"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "operation",
        "operationLength",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'operation', 'operationLength', 'referenceSequence'
    ]

    def __init__(self):
        self.operation = None
        self.operationLength = None
        self.referenceSequence = None


class DataSetResource(ProtocolElement):
    """
    DataSetResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataSetResource", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "reference"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "DataSizeResource", "fields": [{"doc": "", "type":
"int", "name": "variants"}, {"doc": "", "type": "int", "name":
"samples"}]}], "name": "size"}, {"doc": "", "type": "boolean", "name":
"multiple"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "datasets"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name":
"DataUseResource", "fields": [{"doc": "", "type": "string", "name":
"category"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "DataUseRequirementResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]},
"type": "array"}, "name": "requirements"}]}, "type": "array"}, "name":
"data_use"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "multiple",
        "reference",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'data_use': DataUseResource,
            'size': DataSizeResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'data_use': DataUseResource,
            'size': DataSizeResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'data_use', 'datasets', 'description', 'id', 'multiple',
        'reference', 'size'
    ]

    def __init__(self):
        self.data_use = []
        self.datasets = []
        self.description = None
        self.id = None
        self.multiple = None
        self.reference = None
        self.size = None


class DataSizeResource(ProtocolElement):
    """
    DataSetSizeResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataSizeResource", "fields": [{"doc": "", "type": "int", "name":
"variants"}, {"doc": "", "type": "int", "name": "samples"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "samples",
        "variants",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'samples', 'variants'
    ]

    def __init__(self):
        self.samples = None
        self.variants = None


class DataUseRequirementResource(ProtocolElement):
    """
    DataUseRequirementResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataUseRequirementResource", "fields": [{"doc": "", "type": "string",
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "name",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'name'
    ]

    def __init__(self):
        self.description = None
        self.name = None


class DataUseResource(ProtocolElement):
    """
    DataUseResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"DataUseResource", "fields": [{"doc": "", "type": "string", "name":
"category"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "DataUseRequirementResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]},
"type": "array"}, "name": "requirements"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "category",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'requirements': DataUseRequirementResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'requirements': DataUseRequirementResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'category', 'description', 'requirements'
    ]

    def __init__(self):
        self.category = None
        self.description = None
        self.requirements = []


class Dataset(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Dataset",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id'
    ]

    def __init__(self):
        self.description = None
        self.id = None


class ErrorResource(ProtocolElement):
    """
    ErrorResource
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"ErrorResource", "fields": [{"doc": "", "type": "string", "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "name",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'name'
    ]

    def __init__(self):
        self.description = None
        self.name = None


class Experiment(ProtocolElement):
    """
    An experimental preparation of a `Sample`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Experiment", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "created"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "updated"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "runDate"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "molecule"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "strategy"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"selection"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "library"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "libraryLayout"}, {"doc": "", "type": ["null",
"string"], "name": "instrumentModel"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "instrumentDataFile"}, {"doc": "",
"type": ["null", "string"], "name": "sequencingCenter"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "platformUnit"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "instrumentModel",
        "sequencingCenter",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'description', 'id', 'info', 'instrumentDataFile',
        'instrumentModel', 'library', 'libraryLayout', 'molecule',
        'name', 'platformUnit', 'runDate', 'selection',
        'sequencingCenter', 'strategy', 'updated'
    ]

    def __init__(self):
        self.created = None
        self.description = None
        self.id = None
        self.info = {}
        self.instrumentDataFile = None
        self.instrumentModel = None
        self.library = None
        self.libraryLayout = None
        self.molecule = None
        self.name = None
        self.platformUnit = None
        self.runDate = None
        self.selection = None
        self.sequencingCenter = None
        self.strategy = None
        self.updated = None


class ExternalIdentifier(ProtocolElement):
    """
    Identifier from a public database
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ExternalIdentifier", "fields": [{"doc": "", "type": "string", "name":
"database"}, {"doc": "", "type": "string", "name": "identifier"},
{"doc": "", "type": "string", "name": "version"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "database",
        "identifier",
        "version",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'database', 'identifier', 'version'
    ]

    def __init__(self):
        self.database = None
        self.identifier = None
        self.version = None


class ExtractSubgraphJoinsRequest(ProtocolElement):
    """
    This request maps to the body of `POST /subgraph/joins` as JSON.
    Specifies a`Position` and a radius (in bases), and requests all
    `Join`s reachable within that number of bases from that position.
    Starting at the specified `Position`, and with a 0 radius denoting
    only that `Position`, walk outwards this many bases along all
    possible paths, traversing `Join`s only if necessary. All `Join`s
    traversed during this walk should be returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ExtractSubgraphJoinsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"doc": "", "type": {"namespace": "org.ga4gh.models", "type":
"record", "name": "Position", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "sequenceId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"doc": "", "type": "long", "name": "position"}], "doc": ""}, "name":
"position"}, {"doc": "", "type": "long", "name": "radius"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
        "radius",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken', 'position', 'radius',
        'referenceSetId', 'variantSetId'
    ]

    def __init__(self):
        self.pageSize = None
        self.pageToken = None
        self.position = None
        self.radius = None
        self.referenceSetId = None
        self.variantSetId = None


class ExtractSubgraphJoinsResponse(ProtocolElement):
    """
    This is the response from `POST /subgraph/joins` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ExtractSubgraphJoinsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Join", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "side1"}, {"doc": "", "type": "Side", "name":
"side2"}], "doc": ""}, "type": "array"}, "name": "joins"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'joins', 'nextPageToken'
    ]

    def __init__(self):
        self.joins = []
        self.nextPageToken = None


class ExtractSubgraphSegmentsRequest(ProtocolElement):
    """
    This request maps to the body of `POST /subgraph/sequences` as
    JSON. Specifies a`Position` and a radius (in bases), and requests
    all `Segment`s reachable within that number of bases from that
    position.  Starting at the specified `Position`, and with a 0
    radius denoting only that `Position`, walk outwards this many
    bases along all possible paths, traversing `Join`s only if
    necessary. All `Segment`s covering all bases visited during this
    walk should be returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ExtractSubgraphSegmentsRequest", "fields": [{"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"doc": "", "type": {"namespace": "org.ga4gh.models", "type":
"record", "name": "Position", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "sequenceId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"doc": "", "type": "long", "name": "position"}], "doc": ""}, "name":
"position"}, {"doc": "", "type": "long", "name": "radius"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
        "radius",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'position': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken', 'position', 'radius',
        'referenceSetId', 'variantSetId'
    ]

    def __init__(self):
        self.pageSize = None
        self.pageToken = None
        self.position = None
        self.radius = None
        self.referenceSetId = None
        self.variantSetId = None


class ExtractSubgraphSegmentsResponse(ProtocolElement):
    """
    This is the response from `POST /subgraph/segments` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ExtractSubgraphSegmentsResponse", "fields": [{"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "Segment", "fields": [{"doc": "", "type": {"doc":
"", "type": "record", "name": "Side", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}], "doc": ""}, "type": "array"},
"name": "segments"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'segments'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.segments = []


class Feature(ProtocolElement):
    """
    Node in the annotation graph that annotates a contiguous region of
    a   sequence.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Feature",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": {"items": "string", "type": "array"}, "name": "parentIds"},
{"doc": "", "type": "string", "name": "featureSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "referenceName"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"start"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "end"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "OntologyTerm", "fields": [{"doc": "", "type": "string",
"name": "ontologySource"}, {"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}]}, "name": "featureType"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "Attributes", "fields": [{"default": {},
"type": {"values": {"items": ["string", {"doc": "", "type": "record",
"name": "ExternalIdentifier", "fields": [{"doc": "", "type": "string",
"name": "database"}, {"doc": "", "type": "string", "name":
"identifier"}, {"doc": "", "type": "string", "name": "version"}]},
"OntologyTerm"], "type": "array"}, "type": "map"}, "name": "vals"}]},
"name": "attributes"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "featureSetId",
        "featureType",
        "id",
        "parentIds",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
            'featureType': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'end', 'featureSetId', 'featureType', 'id',
        'parentIds', 'referenceName', 'start'
    ]

    def __init__(self):
        self.attributes = None
        self.end = None
        self.featureSetId = None
        self.featureType = None
        self.id = None
        self.parentIds = None
        self.referenceName = None
        self.start = None


class FeatureSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"FeatureSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"doc": "", "type": ["null", "string"], "name":
"referenceSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "sourceURI"}, {"doc": "", "type": {"doc":
"", "type": "record", "name": "Attributes", "fields": [{"default": {},
"type": {"values": {"items": ["string", {"doc": "", "type": "record",
"name": "ExternalIdentifier", "fields": [{"doc": "", "type": "string",
"name": "database"}, {"doc": "", "type": "string", "name":
"identifier"}, {"doc": "", "type": "string", "name": "version"}]},
{"doc": "", "type": "record", "name": "OntologyTerm", "fields":
[{"doc": "", "type": "string", "name": "ontologySource"}, {"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}]}], "type": "array"}, "type":
"map"}, "name": "vals"}]}, "name": "attributes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'datasetId', 'id', 'name', 'referenceSetId',
        'sourceURI'
    ]

    def __init__(self):
        self.attributes = None
        self.datasetId = None
        self.id = None
        self.name = None
        self.referenceSetId = None
        self.sourceURI = None


class Fragment(ProtocolElement):
    """
    A fragment represents a contiguous stretch of a DNA or RNA
    molecule. Reads can be associated with a fragment to specify they
    derive from the same molecule.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Fragment", "fields": [{"doc": "", "type": "string", "name": "id"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id'
    ]

    def __init__(self):
        self.id = None


class GAException(ProtocolElement):
    """
    A general exception type.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "error", "name":
"GAException", "fields": [{"doc": "", "type": "string", "name":
"message"}, {"default": -1, "doc": "", "type": "int", "name":
"errorCode"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "message",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'errorCode', 'message'
    ]

    def __init__(self):
        self.errorCode = -1
        self.message = None


class GetSequenceBasesRequest(ProtocolElement):
    """
    The query parameters for a request to `GET /sequence/{id}`, for
    example:  `GET /sequence/c95d4520-8c63-45f1-924d-
    6a9604a919fb?start=100&end=200`
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"GetSequenceBasesRequest", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "start"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "end"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageToken', 'start'
    ]

    def __init__(self):
        self.end = None
        self.pageToken = None
        self.start = 0


class GetSequenceBasesResponse(ProtocolElement):
    """
    The response from `GET /sequence/{id}` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"GetSequenceBasesResponse", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "offset"}, {"doc": "", "type": "string",
"name": "sequence"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "sequence",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'offset', 'sequence'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.offset = 0
        self.sequence = None


class GraphAlignment(ProtocolElement):
    """
    A string-to-reference-graph alignment can be represented by one
    CIGAR string and one `Path` through multiple `Reference`s, against
    which the CIGAR string is interpreted.  Note that `Path`s in
    `GraphAlignment`s are restricted to visiting `Reference`s and
    following reference adjacencies. If a read needs to be aligned to
    sequences that are not present in a `ReferenceSet`, it needs to be
    aligned to a new `ReferenceSet` with those sequences. If a read
    needs to follow adjacencies that are not present in the
    `ReferenceSet` it's being aligned to, it should be represented as
    a "chimeric" alignment, and should use multiple `ReadAlignment`s
    and the supplementaryAlignment flag instead of a single
    `GraphAlignment`.  Some especially large deletions could be
    represented just as well as a large deletion in the CIGAR string,
    or as a chimeric alignment.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"GraphAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Path", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "start"},
{"doc": "", "type": "long", "name": "length"}]}, "type": "array"},
"name": "segments"}]}, "name": "path"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "mappingQuality"}, {"default": [],
"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"CigarUnit", "fields": [{"doc": "", "type": {"symbols":
["ALIGNMENT_MATCH", "INSERT", "DELETE", "SKIP", "CLIP_SOFT",
"CLIP_HARD", "PAD", "SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "",
"type": "enum", "name": "CigarOperation"}, "name": "operation"},
{"doc": "", "type": "long", "name": "operationLength"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"referenceSequence"}]}, "type": "array"}, "name": "cigar"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "path",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'path': Path,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'path': Path,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'cigar', 'mappingQuality', 'path'
    ]

    def __init__(self):
        self.cigar = []
        self.mappingQuality = None
        self.path = None


class Individual(ProtocolElement):
    """
    An individual (or subject) typically corresponds to an individual
    human or other organism.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Individual", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "groupIds"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "created"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "updated"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "ontologySource"}, {"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}], "name": "species"}, {"default": null,
"doc": "", "type": ["null", "OntologyTerm"], "name": "sex"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"developmentalStage"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "dateOfBirth"}, {"default": [], "doc": "", "type":
{"items": "OntologyTerm", "type": "array"}, "name": "diseases"},
{"default": [], "doc": "", "type": {"items": "OntologyTerm", "type":
"array"}, "name": "phenotypes"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "stagingSystem"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "clinicalTreatment"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strain"}, {"default": {}, "doc": "", "type": {"values": {"items":
"string", "type": "array"}, "type": "map"}, "name": "info"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'developmentalStage': OntologyTerm,
            'diseases': OntologyTerm,
            'phenotypes': OntologyTerm,
            'sex': OntologyTerm,
            'species': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'developmentalStage': OntologyTerm,
            'diseases': OntologyTerm,
            'phenotypes': OntologyTerm,
            'sex': OntologyTerm,
            'species': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'clinicalTreatment', 'created', 'dateOfBirth', 'description',
        'developmentalStage', 'diseases', 'groupIds', 'id', 'info',
        'name', 'phenotypes', 'sex', 'species', 'stagingSystem',
        'strain', 'updated'
    ]

    def __init__(self):
        self.clinicalTreatment = None
        self.created = None
        self.dateOfBirth = None
        self.description = None
        self.developmentalStage = None
        self.diseases = []
        self.groupIds = []
        self.id = None
        self.info = {}
        self.name = None
        self.phenotypes = []
        self.sex = None
        self.species = None
        self.stagingSystem = None
        self.strain = None
        self.updated = None


class IndividualGroup(ProtocolElement):
    """
    Represents a group of individuals. (e.g. a trio)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"IndividualGroup", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "created"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "updated"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "type"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'description', 'id', 'info', 'name', 'type',
        'updated'
    ]

    def __init__(self):
        self.created = None
        self.description = None
        self.id = None
        self.info = {}
        self.name = None
        self.type = None
        self.updated = None


class Join(ProtocolElement):
    """
    A `Join` is simply a pair of `Side` objects. The are logically
    unordered (i.e. swapping makes no difference), but we require a
    rank on the Sequences, and so implicitly on the sides, so to avoid
    ambiguity we require that the side for side1 is less than that for
    side2.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Join",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "side1"},
{"doc": "", "type": "Side", "name": "side2"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "side1",
        "side2",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'side1': Side,
            'side2': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'side1': Side,
            'side2': Side,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'side1', 'side2'
    ]

    def __init__(self):
        self.side1 = None
        self.side2 = None


class LinearAlignment(ProtocolElement):
    """
    A linear alignment can be represented by one CIGAR string.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"LinearAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Side", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Position", "fields": [{"default": null,
"doc": "", "type": ["null", "string"], "name": "sequenceId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceName"}, {"doc": "", "type": "long", "name": "position"}]},
"name": "base"}, {"doc": "", "type": {"symbols": ["NEG_STRAND",
"POS_STRAND"], "doc": "", "type": "enum", "name": "Strand"}, "name":
"strand"}]}, "name": "position"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "CigarUnit",
"fields": [{"doc": "", "type": {"symbols": ["ALIGNMENT_MATCH",
"INSERT", "DELETE", "SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD",
"SEQUENCE_MATCH", "SEQUENCE_MISMATCH"], "doc": "", "type": "enum",
"name": "CigarOperation"}, "name": "operation"}, {"doc": "", "type":
"long", "name": "operationLength"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSequence"}]}, "type":
"array"}, "name": "cigar"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cigar': CigarUnit,
            'position': Side,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'cigar', 'mappingQuality', 'position'
    ]

    def __init__(self):
        self.cigar = []
        self.mappingQuality = None
        self.position = None


class ListReferenceBasesRequest(ProtocolElement):
    """
    The query parameters for a request to `GET
    /references/{id}/bases`, for example:  `GET
    /references/{id}/bases?start=100&end=200`
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesRequest", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "start"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "end"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageToken', 'start'
    ]

    def __init__(self):
        self.end = None
        self.pageToken = None
        self.start = 0


class ListReferenceBasesResponse(ProtocolElement):
    """
    The response from `GET /references/{id}/bases` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"ListReferenceBasesResponse", "fields": [{"default": 0, "doc": "",
"type": "long", "name": "offset"}, {"doc": "", "type": "string",
"name": "sequence"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "sequence",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'offset', 'sequence'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.offset = 0
        self.sequence = None


class OntologyTerm(ProtocolElement):
    """
    An ontology term describing an attribute. (e.g. the phenotype
    attribute 'polydactyly' from HPO)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "ontologySource",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'name', 'ontologySource'
    ]

    def __init__(self):
        self.id = None
        self.name = None
        self.ontologySource = None


class Path(ProtocolElement):
    """
    A `Path` is an ordered list of `Segment`s. In general any
    contiguous path through a sequence graph, with no novel
    adjacencies, can be represented by a `Path`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Path",
"fields": [{"default": [], "doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "Segment", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Side", "fields": [{"doc": "",
"type": {"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'segments': Segment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'segments'
    ]

    def __init__(self):
        self.segments = []


class Position(ProtocolElement):
    """
    A `Position` is an unoriented base in some already known sequence.
    A `Position` is represented by a sequence name or ID, and a base
    number on that sequence (0-based).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "position",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'position', 'referenceName', 'sequenceId'
    ]

    def __init__(self):
        self.position = None
        self.referenceName = None
        self.sequenceId = None


class Program(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Program",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "commandLine"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "prevProgramId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "version"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'commandLine', 'id', 'name', 'prevProgramId', 'version'
    ]

    def __init__(self):
        self.commandLine = None
        self.id = None
        self.name = None
        self.prevProgramId = None
        self.version = None


class QueryResource(ProtocolElement):
    """
    A request for information about a specific site
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"QueryResource", "fields": [{"doc": "", "type": "string", "name":
"referenceBases"}, {"doc": "", "type": "string", "name":
"alternateBases"}, {"doc": "", "type": "string", "name":
"chromosome"}, {"doc": "", "type": "long", "name": "position"},
{"doc": "", "type": "string", "name": "reference"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "dataset"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "alternateBases",
        "chromosome",
        "position",
        "reference",
        "referenceBases",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alternateBases', 'chromosome', 'dataset', 'position',
        'reference', 'referenceBases'
    ]

    def __init__(self):
        self.alternateBases = None
        self.chromosome = None
        self.dataset = None
        self.position = None
        self.reference = None
        self.referenceBases = None


class ReadAlignment(ProtocolElement):
    """
    Each read alignment describes an alignment with additional
    information about the fragment and the read. A read alignment
    object is equivalent to a line in a SAM file.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentId"}, {"doc": "",
"type": "string", "name": "fragmentName"}, {"default": false, "doc":
"", "type": "boolean", "name": "properPlacement"}, {"default": false,
"doc": "", "type": "boolean", "name": "duplicateFragment"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"numberReads"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "fragmentLength"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "readNumber"}, {"default": false, "doc": "",
"type": "boolean", "name": "failedVendorQualityChecks"}, {"default":
null, "doc": "", "type": ["null", {"doc": "", "type": "record",
"name": "LinearAlignment", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Side", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "position"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"mappingQuality"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "CigarUnit", "fields": [{"doc":
"", "type": {"symbols": ["ALIGNMENT_MATCH", "INSERT", "DELETE",
"SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD", "SEQUENCE_MATCH",
"SEQUENCE_MISMATCH"], "doc": "", "type": "enum", "name":
"CigarOperation"}, "name": "operation"}, {"doc": "", "type": "long",
"name": "operationLength"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceSequence"}]}, "type": "array"},
"name": "cigar"}]}, {"doc": "", "type": "record", "name":
"GraphAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Path", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": "Side", "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": "CigarUnit", "type": "array"}, "name": "cigar"}]}],
"name": "alignment"}, {"default": false, "doc": "", "type": "boolean",
"name": "secondaryAlignment"}, {"default": false, "doc": "", "type":
"boolean", "name": "supplementaryAlignment"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "alignedSequence"},
{"default": [], "doc": "", "type": {"items": "int", "type": "array"},
"name": "alignedQuality"}, {"default": null, "doc": "", "type":
["null", "Side"], "name": "nextMatePosition"}, {"default": {}, "doc":
"", "type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "fragmentId",
        "fragmentName",
        "id",
        "readGroupId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignment': LinearAlignment,
            'nextMatePosition': Side,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedQuality', 'alignedSequence', 'alignment',
        'duplicateFragment', 'failedVendorQualityChecks',
        'fragmentId', 'fragmentLength', 'fragmentName', 'id', 'info',
        'nextMatePosition', 'numberReads', 'properPlacement',
        'readGroupId', 'readNumber', 'secondaryAlignment',
        'supplementaryAlignment'
    ]

    def __init__(self):
        self.alignedQuality = []
        self.alignedSequence = None
        self.alignment = None
        self.duplicateFragment = False
        self.failedVendorQualityChecks = False
        self.fragmentId = None
        self.fragmentLength = None
        self.fragmentName = None
        self.id = None
        self.info = {}
        self.nextMatePosition = None
        self.numberReads = None
        self.properPlacement = False
        self.readGroupId = None
        self.readNumber = None
        self.secondaryAlignment = False
        self.supplementaryAlignment = False


class ReadGroup(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroup", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"datasetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"doc": "", "type": ["null",
"string"], "name": "sampleId"}, {"doc": "", "type": ["null", {"doc":
"", "type": "record", "name": "Experiment", "fields": [{"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "created"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "updated"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"runDate"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "molecule"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "strategy"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "selection"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "library"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "libraryLayout"},
{"doc": "", "type": ["null", "string"], "name": "instrumentModel"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"instrumentDataFile"}, {"doc": "", "type": ["null", "string"], "name":
"sequencingCenter"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "platformUnit"}, {"default": {}, "doc": "", "type":
{"values": {"items": "string", "type": "array"}, "type": "map"},
"name": "info"}]}], "name": "experiment"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "predictedInsertSize"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"default": null, "doc": "", "type": ["null",
{"fields": [{"default": null, "doc": "", "type": ["null", "long"],
"name": "alignedReadCount"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "unalignedReadCount"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "baseCount"}], "type":
"record", "name": "ReadStats"}], "name": "stats"}, {"default": [],
"doc": "", "type": {"items": {"fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "commandLine"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"prevProgramId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "version"}], "type": "record", "name": "Program"},
"type": "array"}, "name": "programs"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "experiment",
        "id",
        "sampleId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiment': Experiment,
            'programs': Program,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'created', 'datasetId', 'description', 'experiment', 'id',
        'info', 'name', 'predictedInsertSize', 'programs',
        'referenceSetId', 'sampleId', 'stats', 'updated'
    ]

    def __init__(self):
        self.created = None
        self.datasetId = None
        self.description = None
        self.experiment = None
        self.id = None
        self.info = {}
        self.name = None
        self.predictedInsertSize = None
        self.programs = []
        self.referenceSetId = None
        self.sampleId = None
        self.stats = None
        self.updated = None


class ReadGroupSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadGroupSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "datasetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", {"fields": [{"default": null, "doc": "", "type": ["null",
"long"], "name": "alignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "unalignedReadCount"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "baseCount"}],
"type": "record", "name": "ReadStats"}], "name": "stats"}, {"default":
[], "doc": "", "type": {"items": {"fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"doc": "",
"type": ["null", "string"], "name": "sampleId"}, {"doc": "", "type":
["null", {"doc": "", "type": "record", "name": "Experiment", "fields":
[{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "runDate"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "molecule"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "strategy"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "selection"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"library"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "libraryLayout"}, {"doc": "", "type": ["null", "string"],
"name": "instrumentModel"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "instrumentDataFile"}, {"doc": "", "type":
["null", "string"], "name": "sequencingCenter"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "platformUnit"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}]}], "name":
"experiment"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "predictedInsertSize"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"default": null, "doc":
"", "type": ["null", "ReadStats"], "name": "stats"}, {"default": [],
"doc": "", "type": {"items": {"fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "commandLine"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"prevProgramId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "version"}], "type": "record", "name": "Program"},
"type": "array"}, "name": "programs"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}], "type": "record", "name":
"ReadGroup"}, "type": "array"}, "name": "readGroups"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroups': ReadGroup,
            'stats': ReadStats,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'name', 'readGroups', 'stats'
    ]

    def __init__(self):
        self.datasetId = None
        self.id = None
        self.name = None
        self.readGroups = []
        self.stats = None


class ReadStats(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadStats", "fields": [{"default": null, "doc": "", "type": ["null",
"long"], "name": "alignedReadCount"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "unalignedReadCount"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "baseCount"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignedReadCount', 'baseCount', 'unalignedReadCount'
    ]

    def __init__(self):
        self.alignedReadCount = None
        self.baseCount = None
        self.unalignedReadCount = None


class Reference(ProtocolElement):
    """
    A `Reference` is a canonical assembled contig, intended to act as
    a reference coordinate space for other genomic annotations. A
    single `Reference` might represent the human chromosome 1, for
    instance.  `Reference`s are designed to be immutable. When
    extending a `ReferenceSet` with new `Reference`s, the existing
    `References` should not be changed. Newly added `Reference`
    `Sequence`s may be children of existing `Reference` `Sequence`s,
    but existing `Reference` `Sequence`s should not be made to be
    children of newly added `Reference` `Sequence`s.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Reference", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "sequenceId"}, {"doc": "",
"type": "long", "name": "start"}, {"doc": "", "type": "long", "name":
"length"}, {"doc": "", "type": "string", "name": "md5checksum"},
{"doc": "", "type": "string", "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}, {"default": null, "doc": "", "type": ["null",
"float"], "name": "sourceDivergence"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "ncbiTaxonId"}, {"default": true,
"doc": "", "type": "boolean", "name": "isPrimary"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "length",
        "md5checksum",
        "name",
        "sequenceId",
        "sourceAccessions",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'isDerived', 'isPrimary', 'length', 'md5checksum',
        'name', 'ncbiTaxonId', 'sequenceId', 'sourceAccessions',
        'sourceDivergence', 'sourceURI', 'start'
    ]

    def __init__(self):
        self.id = None
        self.isDerived = False
        self.isPrimary = True
        self.length = None
        self.md5checksum = None
        self.name = None
        self.ncbiTaxonId = None
        self.sequenceId = None
        self.sourceAccessions = None
        self.sourceDivergence = None
        self.sourceURI = None
        self.start = None


class ReferenceSet(ProtocolElement):
    """
    A `ReferenceSet` is a set of `Reference`s which typically comprise
    a reference assembly, such as `GRCh38`. A `ReferenceSet` defines a
    common coordinate space for comparing reference-aligned
    experimental data.  `ReferenceSet`s are composeable: a
    `ReferenceSet` may incorporate all of the `Reference`s and `Join`s
    from one or more other `ReferenceSet`s via the
    `includedReferenceSet`s array.  In classic mode, this is just a
    set of sequences.  In graph mode, there are both sequences and
    joins, but we only access the joins via method
    getReferenceJoins().
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"ReferenceSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "referenceIds"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"includedReferenceSets"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "md5checksum",
        "sourceAccessions",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'assemblyId', 'description', 'id', 'includedReferenceSets',
        'isDerived', 'md5checksum', 'ncbiTaxonId', 'referenceIds',
        'sourceAccessions', 'sourceURI'
    ]

    def __init__(self):
        self.assemblyId = None
        self.description = None
        self.id = None
        self.includedReferenceSets = []
        self.isDerived = False
        self.md5checksum = None
        self.ncbiTaxonId = None
        self.referenceIds = None
        self.sourceAccessions = None
        self.sourceURI = None


class Region(ProtocolElement):
    """
    An abstraction for referring to a genomic region, in relation to
    some already  known reference. This will require some significant
    rework as we move to graph coordinates.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Region",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}]}, "name": "start"}, {"doc": "", "type":
"long", "name": "length"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "length",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'length', 'start'
    ]

    def __init__(self):
        self.length = None
        self.start = None


class ResponseResource(ProtocolElement):
    """
    The response to the Beacon query
    """
    _schemaSource = """
{"namespace": "org.ga4gh.beacon", "type": "record", "name":
"ResponseResource", "fields": [{"doc": "", "type": "string", "name":
"exists"}, {"doc": "", "type": ["null", "double"], "name":
"frequency"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "observed"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "info"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "ErrorResource",
"fields": [{"doc": "", "type": "string", "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"description"}]}], "name": "err"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "exists",
        "frequency",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'err': ErrorResource,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'err': ErrorResource,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'err', 'exists', 'frequency', 'info', 'observed'
    ]

    def __init__(self):
        self.err = None
        self.exists = None
        self.frequency = None
        self.info = None
        self.observed = None


class Sample(ProtocolElement):
    """
    A biological sample used in an experiment. (e.g. whole blood from
    an affected individual)
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Sample",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "individualId"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "accessions"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "created"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "updated"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"samplingDate"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "age"}, {"default": null, "doc": "", "type": ["null",
{"doc": "", "type": "record", "name": "OntologyTerm", "fields":
[{"doc": "", "type": "string", "name": "ontologySource"}, {"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}]}], "name": "cellType"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"cellLine"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "geocode"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "sampleType"}, {"default": null, "doc": "", "type":
["null", "OntologyTerm"], "name": "organismPart"}, {"default": {},
"doc": "", "type": {"values": {"items": "string", "type": "array"},
"type": "map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cellLine': OntologyTerm,
            'cellType': OntologyTerm,
            'organismPart': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cellLine': OntologyTerm,
            'cellType': OntologyTerm,
            'organismPart': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'accessions', 'age', 'cellLine', 'cellType', 'created',
        'description', 'geocode', 'id', 'individualId', 'info',
        'name', 'organismPart', 'sampleType', 'samplingDate',
        'updated'
    ]

    def __init__(self):
        self.accessions = []
        self.age = None
        self.cellLine = None
        self.cellType = None
        self.created = None
        self.description = None
        self.geocode = None
        self.id = None
        self.individualId = None
        self.info = {}
        self.name = None
        self.organismPart = None
        self.sampleType = None
        self.samplingDate = None
        self.updated = None


class SearchAlleleCallsRequest(SearchRequest):
    """
    This request maps to the body of `POST /allelecalls/search` as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAlleleCallsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "callSetIds"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "variantSetIds"}, {"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "alleleIds"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "variantIds"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alleleIds', 'callSetIds', 'pageSize', 'pageToken',
        'variantIds', 'variantSetIds'
    ]

    def __init__(self):
        self.alleleIds = []
        self.callSetIds = []
        self.pageSize = None
        self.pageToken = None
        self.variantIds = []
        self.variantSetIds = []


class SearchAlleleCallsResponse(SearchResponse):
    """
    This is the response from `POST /allelecalls/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAlleleCallsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "AlleleCall", "fields": [{"doc": "", "type": "string", "name":
"callSetId"}, {"doc": "", "type": "string", "name": "alleleId"},
{"doc": "", "type": ["null", "string"], "name": "variantId"}, {"doc":
"", "type": "double", "name": "totalCopies"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "phaseset"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}, "type":
"array"}, "name": "alleleCalls"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alleleCalls"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleleCalls': AlleleCall,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleleCalls': AlleleCall,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alleleCalls', 'nextPageToken'
    ]

    def __init__(self):
        self.alleleCalls = []
        self.nextPageToken = None


class SearchAllelesRequest(SearchRequest):
    """
    This request maps to the body of `POST /alleles/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAllelesRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "variantSetIds"},
{"doc": "", "type": "string", "name": "sequenceId"}, {"doc": "",
"type": "long", "name": "start"}, {"doc": "", "type": "long", "name":
"end"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "sequenceId",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageSize', 'pageToken', 'sequenceId', 'start',
        'variantSetIds'
    ]

    def __init__(self):
        self.end = None
        self.pageSize = None
        self.pageToken = None
        self.sequenceId = None
        self.start = None
        self.variantSetIds = []


class SearchAllelesResponse(SearchResponse):
    """
    This is the response from `POST /alleles/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAllelesResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Allele", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "variantSetId"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Path", "fields":
[{"default": [], "doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Segment", "fields": [{"doc": "", "type": {"doc":
"", "type": "record", "name": "Side", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}], "doc": ""}, "type": "array"}, "name":
"alleles"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alleles"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleles': Allele,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alleles': Allele,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alleles', 'nextPageToken'
    ]

    def __init__(self):
        self.alleles = []
        self.nextPageToken = None


class SearchAnalysesRequest(SearchRequest):
    """
    This request maps to the body of `POST /analyses/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAnalysesRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "name"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken'
    ]

    def __init__(self):
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchAnalysesResponse(SearchResponse):
    """
    This is the response from `POST /analyses/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchAnalysesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Analysis", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "created"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "updated"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "type"}, {"default":
[], "doc": "", "type": {"items": "string", "type": "array"}, "name":
"software"}, {"default": {}, "doc": "", "type": {"values": {"items":
"string", "type": "array"}, "type": "map"}, "name": "info"}], "doc":
""}, "type": "array"}, "name": "analyses"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "analyses"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'analyses': Analysis,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'analyses': Analysis,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'analyses', 'nextPageToken'
    ]

    def __init__(self):
        self.analyses = []
        self.nextPageToken = None


class SearchCallSetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /callsets/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "variantSetIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken', 'variantSetIds'
    ]

    def __init__(self):
        self.name = None
        self.pageSize = None
        self.pageToken = None
        self.variantSetIds = []


class SearchCallSetsResponse(SearchResponse):
    """
    This is the response from `POST /callsets/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "CallSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"doc": "", "type": ["null", "string"], "name":
"sampleId"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "variantSetIds"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "created"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "updated"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}, "type":
"array"}, "name": "callSets"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "callSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'callSets': CallSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSets', 'nextPageToken'
    ]

    def __init__(self):
        self.callSets = []
        self.nextPageToken = None


class SearchCallsRequest(SearchRequest):
    """
    This request maps to the body of `POST /calls/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallsRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "callSetIds"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "variantSetIds"}, {"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "variantIds"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetIds', 'pageSize', 'pageToken', 'variantIds',
        'variantSetIds'
    ]

    def __init__(self):
        self.callSetIds = []
        self.pageSize = None
        self.pageToken = None
        self.variantIds = []
        self.variantSetIds = []


class SearchCallsResponse(SearchResponse):
    """
    This is the response from `POST /calls/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchCallsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Call", "fields": [{"doc": "", "type": ["null", "string"], "name":
"callSetId"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "callSetName"}, {"doc": "", "type": ["null", "string"],
"name": "variantId"}, {"default": [], "doc": "", "type": {"items":
"int", "type": "array"}, "name": "genotype"}, {"default": null, "doc":
"", "type": ["null", "string", {"items": "string", "type": "array"}],
"name": "phaseset"}, {"default": [], "doc": "", "type": {"items":
"double", "type": "array"}, "name": "genotypeLikelihood"}, {"default":
{}, "doc": "", "type": {"values": {"items": "string", "type":
"array"}, "type": "map"}, "name": "info"}], "doc": ""}, "type":
"array"}, "name": "calls"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "calls"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calls': Call,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'calls', 'nextPageToken'
    ]

    def __init__(self):
        self.calls = []
        self.nextPageToken = None


class SearchDatasetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /datasets/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken'
    ]

    def __init__(self):
        self.pageSize = None
        self.pageToken = None


class SearchDatasetsResponse(SearchResponse):
    """
    This is the response from `POST /datasets/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchDatasetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Dataset", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "description"}]}, "type": "array"}, "name": "datasets"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "datasets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'datasets': Dataset,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasets', 'nextPageToken'
    ]

    def __init__(self):
        self.datasets = []
        self.nextPageToken = None


class SearchExperimentsRequest(SearchRequest):
    """
    This request maps to the body of `POST /experiments/search` as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchExperimentsRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "name"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken'
    ]

    def __init__(self):
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchExperimentsResponse(SearchResponse):
    """
    This is the response from `POST /experiments/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchExperimentsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Experiment", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "name"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "created"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "updated"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "runDate"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "molecule"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strategy"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "selection"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "library"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "libraryLayout"}, {"doc": "", "type":
["null", "string"], "name": "instrumentModel"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "instrumentDataFile"},
{"doc": "", "type": ["null", "string"], "name": "sequencingCenter"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"platformUnit"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}], "doc": ""}, "type": "array"}, "name": "experiments"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "experiments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiments': Experiment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'experiments': Experiment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'experiments', 'nextPageToken'
    ]

    def __init__(self):
        self.experiments = []
        self.nextPageToken = None


class SearchFeaturesRequest(SearchRequest):
    """
    This request maps to the body of `POST /features/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeaturesRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "featureSetIds"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "parentIds"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceId"}, {"doc": "",
"type": "long", "name": "start"}, {"doc": "", "type": "long", "name":
"end"}, {"default": [], "doc": "", "type": {"items": {"namespace":
"org.ga4gh.models", "type": "record", "name": "OntologyTerm",
"fields": [{"doc": "", "type": "string", "name": "ontologySource"},
{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}], "doc": ""}, "type":
"array"}, "name": "features"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "pageSize"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': OntologyTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': OntologyTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'featureSetIds', 'features', 'pageSize', 'pageToken',
        'parentIds', 'referenceId', 'referenceName', 'start'
    ]

    def __init__(self):
        self.end = None
        self.featureSetIds = []
        self.features = []
        self.pageSize = None
        self.pageToken = None
        self.parentIds = []
        self.referenceId = None
        self.referenceName = None
        self.start = None


class SearchFeaturesResponse(SearchResponse):
    """
    This is the response from `POST /features/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchFeaturesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Feature", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": {"items": "string", "type": "array"},
"name": "parentIds"}, {"doc": "", "type": "string", "name":
"featureSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "start"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "end"}, {"doc": "", "type":
{"doc": "", "type": "record", "name": "OntologyTerm", "fields":
[{"doc": "", "type": "string", "name": "ontologySource"}, {"doc": "",
"type": "string", "name": "id"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}]}, "name": "featureType"}, {"doc":
"", "type": {"doc": "", "type": "record", "name": "Attributes",
"fields": [{"default": {}, "type": {"values": {"items": ["string",
{"doc": "", "type": "record", "name": "ExternalIdentifier", "fields":
[{"doc": "", "type": "string", "name": "database"}, {"doc": "",
"type": "string", "name": "identifier"}, {"doc": "", "type": "string",
"name": "version"}]}, "OntologyTerm"], "type": "array"}, "type":
"map"}, "name": "vals"}]}, "name": "attributes"}], "doc": ""}, "type":
"array"}, "name": "features"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "features"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'features': Feature,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'features', 'nextPageToken'
    ]

    def __init__(self):
        self.features = []
        self.nextPageToken = None


class SearchIndividualGroupsRequest(SearchRequest):
    """
    This request maps to the body of `POST /individualgroups/search`
    as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualGroupsRequest", "fields": [{"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "int"], "name": "pageSize"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "pageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'name', 'pageSize', 'pageToken'
    ]

    def __init__(self):
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchIndividualGroupsResponse(SearchResponse):
    """
    This is the response from `POST /individualgroups/search`
    expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualGroupsResponse", "fields": [{"default": [], "doc":
"", "type": {"items": {"namespace": "org.ga4gh.models", "type":
"record", "name": "IndividualGroup", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "description"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "created"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "updated"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "type"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}], "doc": ""},
"type": "array"}, "name": "individualGroups"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "individualGroups"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individualGroups': IndividualGroup,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individualGroups': IndividualGroup,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'individualGroups', 'nextPageToken'
    ]

    def __init__(self):
        self.individualGroups = []
        self.nextPageToken = None


class SearchIndividualsRequest(SearchRequest):
    """
    This request maps to the body of `POST /individuals/search` as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "groupIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'groupIds', 'name', 'pageSize', 'pageToken'
    ]

    def __init__(self):
        self.groupIds = []
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchIndividualsResponse(SearchResponse):
    """
    This is the response from `POST /individuals/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchIndividualsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Individual", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "groupIds"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "description"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "created"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "updated"},
{"default": null, "doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "OntologyTerm", "fields": [{"doc": "", "type":
"string", "name": "ontologySource"}, {"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}]}], "name": "species"}, {"default": null,
"doc": "", "type": ["null", "OntologyTerm"], "name": "sex"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"developmentalStage"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "dateOfBirth"}, {"default": [], "doc": "", "type":
{"items": "OntologyTerm", "type": "array"}, "name": "diseases"},
{"default": [], "doc": "", "type": {"items": "OntologyTerm", "type":
"array"}, "name": "phenotypes"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "stagingSystem"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "clinicalTreatment"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"strain"}, {"default": {}, "doc": "", "type": {"values": {"items":
"string", "type": "array"}, "type": "map"}, "name": "info"}], "doc":
""}, "type": "array"}, "name": "individuals"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "individuals"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individuals': Individual,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'individuals': Individual,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'individuals', 'nextPageToken'
    ]

    def __init__(self):
        self.individuals = []
        self.nextPageToken = None


class SearchJoinsRequest(SearchRequest):
    """
    This request maps to the body of `POST /joins/search` as JSON.
    Specifies a number of filters, all of which must be satisfied by
    each result returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchJoinsRequest", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "referenceSetId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "start"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "length"}, {"default": null, "doc": "", "type":
["null", {"symbols": ["NEG_STRAND", "POS_STRAND"], "namespace":
"org.ga4gh.models", "type": "enum", "name": "Strand", "doc": ""}],
"name": "strand"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "pageSize"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'length', 'pageSize', 'pageToken', 'referenceSetId',
        'sequenceId', 'start', 'strand', 'variantSetId'
    ]

    def __init__(self):
        self.length = None
        self.pageSize = None
        self.pageToken = None
        self.referenceSetId = None
        self.sequenceId = None
        self.start = None
        self.strand = None
        self.variantSetId = None


class SearchJoinsResponse(SearchResponse):
    """
    This is the response from `POST /joins/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchJoinsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Join", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Side", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Position", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "sequenceId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"doc": "", "type": "long", "name": "position"}]}, "name": "base"},
{"doc": "", "type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc":
"", "type": "enum", "name": "Strand"}, "name": "strand"}]}, "name":
"side1"}, {"doc": "", "type": "Side", "name": "side2"}], "doc": ""},
"type": "array"}, "name": "joins"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "joins"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'joins': Join,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'joins', 'nextPageToken'
    ]

    def __init__(self):
        self.joins = []
        self.nextPageToken = None


class SearchReadGroupSetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /readgroupsets/search` as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "datasetIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetIds', 'name', 'pageSize', 'pageToken'
    ]

    def __init__(self):
        self.datasetIds = []
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchReadGroupSetsResponse(SearchResponse):
    """
    This is the response from `POST /readgroupsets/search` expressed
    as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadGroupSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReadGroupSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "datasetId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "name"}, {"default": null, "doc": "",
"type": ["null", {"fields": [{"default": null, "doc": "", "type":
["null", "long"], "name": "alignedReadCount"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "unalignedReadCount"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"baseCount"}], "type": "record", "name": "ReadStats"}], "name":
"stats"}, {"default": [], "doc": "", "type": {"items": {"fields":
[{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "datasetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"description"}, {"doc": "", "type": ["null", "string"], "name":
"sampleId"}, {"doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "Experiment", "fields": [{"doc": "", "type":
"string", "name": "id"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "name"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "description"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "created"}, {"default": null,
"doc": "", "type": ["null", "long"], "name": "updated"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "runDate"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"molecule"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "strategy"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "selection"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "library"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "libraryLayout"}, {"doc": "",
"type": ["null", "string"], "name": "instrumentModel"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"instrumentDataFile"}, {"doc": "", "type": ["null", "string"], "name":
"sequencingCenter"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "platformUnit"}, {"default": {}, "doc": "", "type":
{"values": {"items": "string", "type": "array"}, "type": "map"},
"name": "info"}]}], "name": "experiment"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "predictedInsertSize"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"default": null, "doc": "", "type": ["null",
"ReadStats"], "name": "stats"}, {"default": [], "doc": "", "type":
{"items": {"fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "commandLine"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "prevProgramId"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"version"}], "type": "record", "name": "Program"}, "type": "array"},
"name": "programs"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceSetId"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "type": "record", "name": "ReadGroup"},
"type": "array"}, "name": "readGroups"}]}, "type": "array"}, "name":
"readGroupSets"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "readGroupSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'readGroupSets': ReadGroupSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'readGroupSets'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.readGroupSets = []


class SearchReadsRequest(SearchRequest):
    """
    This request maps to the body of `POST /reads/search` as JSON.  If
    a reference is specified, all queried `ReadGroup`s must be aligned
    to `ReferenceSet`s containing that same `Reference`. If no
    reference is specified, all `ReadGroup`s must be aligned to the
    same `ReferenceSet`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "readGroupIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceId"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "start"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "end"}, {"default": null, "doc": "", "type": ["null",
"int"], "name": "pageSize"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'pageSize', 'pageToken', 'readGroupIds', 'referenceId',
        'start'
    ]

    def __init__(self):
        self.end = None
        self.pageSize = None
        self.pageToken = None
        self.readGroupIds = []
        self.referenceId = None
        self.start = None


class SearchReadsResponse(SearchResponse):
    """
    This is the response from `POST /reads/search` expressed as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReadsResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"ReadAlignment", "fields": [{"doc": "", "type": ["null", "string"],
"name": "id"}, {"doc": "", "type": "string", "name": "readGroupId"},
{"doc": "", "type": "string", "name": "fragmentId"}, {"doc": "",
"type": "string", "name": "fragmentName"}, {"default": false, "doc":
"", "type": "boolean", "name": "properPlacement"}, {"default": false,
"doc": "", "type": "boolean", "name": "duplicateFragment"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"numberReads"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "fragmentLength"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "readNumber"}, {"default": false, "doc": "",
"type": "boolean", "name": "failedVendorQualityChecks"}, {"default":
null, "doc": "", "type": ["null", {"doc": "", "type": "record",
"name": "LinearAlignment", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "Side", "fields": [{"doc": "", "type":
{"doc": "", "type": "record", "name": "Position", "fields":
[{"default": null, "doc": "", "type": ["null", "string"], "name":
"sequenceId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"doc": "", "type": "long",
"name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}]}, "name": "position"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"mappingQuality"}, {"default": [], "doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "CigarUnit", "fields": [{"doc":
"", "type": {"symbols": ["ALIGNMENT_MATCH", "INSERT", "DELETE",
"SKIP", "CLIP_SOFT", "CLIP_HARD", "PAD", "SEQUENCE_MATCH",
"SEQUENCE_MISMATCH"], "doc": "", "type": "enum", "name":
"CigarOperation"}, "name": "operation"}, {"doc": "", "type": "long",
"name": "operationLength"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceSequence"}]}, "type": "array"},
"name": "cigar"}]}, {"doc": "", "type": "record", "name":
"GraphAlignment", "fields": [{"doc": "", "type": {"doc": "", "type":
"record", "name": "Path", "fields": [{"default": [], "doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": "Side", "name": "start"}, {"doc": "",
"type": "long", "name": "length"}]}, "type": "array"}, "name":
"segments"}]}, "name": "path"}, {"default": null, "doc": "", "type":
["null", "int"], "name": "mappingQuality"}, {"default": [], "doc": "",
"type": {"items": "CigarUnit", "type": "array"}, "name": "cigar"}]}],
"name": "alignment"}, {"default": false, "doc": "", "type": "boolean",
"name": "secondaryAlignment"}, {"default": false, "doc": "", "type":
"boolean", "name": "supplementaryAlignment"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "alignedSequence"},
{"default": [], "doc": "", "type": {"items": "int", "type": "array"},
"name": "alignedQuality"}, {"default": null, "doc": "", "type":
["null", "Side"], "name": "nextMatePosition"}, {"default": {}, "doc":
"", "type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}, "type": "array"}, "name":
"alignments"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "alignments"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'alignments': ReadAlignment,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'alignments', 'nextPageToken'
    ]

    def __init__(self):
        self.alignments = []
        self.nextPageToken = None


class SearchReferenceSetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /referencesets/search` as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "md5checksums"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "accessions"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "assemblyId"}, {"default": null, "doc":
"", "type": ["null", "int"], "name": "pageSize"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "pageToken"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accessions', 'assemblyId', 'md5checksums', 'pageSize',
        'pageToken'
    ]

    def __init__(self):
        self.accessions = []
        self.assemblyId = None
        self.md5checksums = []
        self.pageSize = None
        self.pageToken = None


class SearchReferenceSetsResponse(SearchResponse):
    """
    This is the response from `POST /referencesets/search` expressed
    as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferenceSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "ReferenceSet", "fields": [{"doc": "", "type": "string",
"name": "id"}, {"default": null, "doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "referenceIds"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"includedReferenceSets"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"default": null, "doc": "", "type": ["null", "int"],
"name": "ncbiTaxonId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "description"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "assemblyId"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sourceURI"}, {"doc":
"", "type": {"items": "string", "type": "array"}, "name":
"sourceAccessions"}, {"default": false, "doc": "", "type": "boolean",
"name": "isDerived"}], "doc": ""}, "type": "array"}, "name":
"referenceSets"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "referenceSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'referenceSets': ReferenceSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'referenceSets'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.referenceSets = []


class SearchReferencesRequest(SearchRequest):
    """
    This request maps to the body of `POST /references/search` as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default": [],
"doc": "", "type": {"items": "string", "type": "array"}, "name":
"sequenceIds"}, {"default": [], "doc": "", "type": {"items": "string",
"type": "array"}, "name": "md5checksums"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "accessions"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "referenceNames"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'accessions', 'md5checksums', 'pageSize', 'pageToken',
        'referenceNames', 'referenceSetId', 'sequenceIds'
    ]

    def __init__(self):
        self.accessions = []
        self.md5checksums = []
        self.pageSize = None
        self.pageToken = None
        self.referenceNames = []
        self.referenceSetId = None
        self.sequenceIds = []


class SearchReferencesResponse(SearchResponse):
    """
    This is the response from `POST /references/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchReferencesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Reference", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "sequenceId"}, {"doc":
"", "type": "long", "name": "start"}, {"doc": "", "type": "long",
"name": "length"}, {"doc": "", "type": "string", "name":
"md5checksum"}, {"doc": "", "type": "string", "name": "name"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"sourceURI"}, {"doc": "", "type": {"items": "string", "type":
"array"}, "name": "sourceAccessions"}, {"default": false, "doc": "",
"type": "boolean", "name": "isDerived"}, {"default": null, "doc": "",
"type": ["null", "float"], "name": "sourceDivergence"}, {"default":
null, "doc": "", "type": ["null", "int"], "name": "ncbiTaxonId"},
{"default": true, "doc": "", "type": "boolean", "name": "isPrimary"}],
"doc": ""}, "type": "array"}, "name": "references"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "references"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'references': Reference,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'references'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.references = []


class SearchSamplesRequest(SearchRequest):
    """
    This request maps to the body of `POST /samples/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSamplesRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "individualIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'individualIds', 'name', 'pageSize', 'pageToken'
    ]

    def __init__(self):
        self.individualIds = []
        self.name = None
        self.pageSize = None
        self.pageToken = None


class SearchSamplesResponse(SearchResponse):
    """
    This is the response from `POST /samples/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSamplesResponse", "fields": [{"default": [], "doc": "", "type":
{"items": {"namespace": "org.ga4gh.models", "type": "record", "name":
"Sample", "fields": [{"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"individualId"}, {"default": [], "doc": "", "type": {"items":
"string", "type": "array"}, "name": "accessions"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "name"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "description"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"default": null, "doc": "", "type": ["null",
"long"], "name": "samplingDate"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "age"}, {"default": null, "doc": "", "type":
["null", {"doc": "", "type": "record", "name": "OntologyTerm",
"fields": [{"doc": "", "type": "string", "name": "ontologySource"},
{"doc": "", "type": "string", "name": "id"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "name"}]}], "name":
"cellType"}, {"default": null, "doc": "", "type": ["null",
"OntologyTerm"], "name": "cellLine"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "geocode"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "sampleType"},
{"default": null, "doc": "", "type": ["null", "OntologyTerm"], "name":
"organismPart"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}], "doc": ""}, "type": "array"}, "name": "samples"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "samples"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'samples': Sample,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'samples': Sample,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'samples'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.samples = []


class SearchSequencesRequest(SearchRequest):
    """
    This request maps to the body of `POST /sequences/search` as JSON.
    Specifies a number of filters, all of which must be satisfied by
    each result returned.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSequencesRequest", "fields": [{"default": null, "doc": "",
"type": ["null", "string"], "name": "referenceSetId"}, {"default":
null, "doc": "", "type": ["null", "string"], "name": "variantSetId"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'pageSize', 'pageToken', 'referenceSetId', 'variantSetId'
    ]

    def __init__(self):
        self.pageSize = None
        self.pageToken = None
        self.referenceSetId = None
        self.variantSetId = None


class SearchSequencesResponse(SearchResponse):
    """
    This is the response from `POST /sequences/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchSequencesResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Sequence", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "long", "name": "length"}], "doc": ""},
"type": "array"}, "name": "sequences"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "sequences"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'sequences': Sequence,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'sequences': Sequence,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'sequences'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.sequences = []


class SearchVariantSetsRequest(SearchRequest):
    """
    This request maps to the body of `POST /variantsets/search` as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsRequest", "fields": [{"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "datasetIds"},
{"default": null, "doc": "", "type": ["null", "int"], "name":
"pageSize"}, {"default": null, "doc": "", "type": ["null", "string"],
"name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetIds', 'pageSize', 'pageToken'
    ]

    def __init__(self):
        self.datasetIds = []
        self.pageSize = None
        self.pageToken = None


class SearchVariantSetsResponse(SearchResponse):
    """
    This is the response from `POST /variantsets/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantSetsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "VariantSet", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "datasetId"}, {"doc": "",
"type": "string", "name": "referenceSetId"}, {"default": [], "doc":
"", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}, "type": "array"}, "name": "variantSets"}, {"default":
null, "doc": "", "type": ["null", "string"], "name":
"nextPageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variantSets"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variantSets': VariantSet,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variantSets'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.variantSets = []


class SearchVariantsRequest(SearchRequest):
    """
    This request maps to the body of `POST /variants/search` as JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsRequest", "fields": [{"default": [], "doc": "", "type":
{"items": "string", "type": "array"}, "name": "variantSetIds"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}, {"default": null, "doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "callSetIds"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "referenceName"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceId"}, {"doc": "", "type": "long", "name": "start"}, {"doc":
"", "type": "long", "name": "end"}, {"default": null, "doc": "",
"type": ["null", "int"], "name": "pageSize"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "pageToken"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "end",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'callSetIds', 'end', 'name', 'pageSize', 'pageToken',
        'referenceId', 'referenceName', 'start', 'variantSetIds'
    ]

    def __init__(self):
        self.callSetIds = None
        self.end = None
        self.name = None
        self.pageSize = None
        self.pageToken = None
        self.referenceId = None
        self.referenceName = None
        self.start = None
        self.variantSetIds = []


class SearchVariantsResponse(SearchResponse):
    """
    This is the response from `POST /variants/search` expressed as
    JSON.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.methods", "type": "record", "name":
"SearchVariantsResponse", "fields": [{"default": [], "doc": "",
"type": {"items": {"namespace": "org.ga4gh.models", "type": "record",
"name": "Variant", "fields": [{"doc": "", "type": "string", "name":
"id"}, {"doc": "", "type": "string", "name": "variantSetId"},
{"default": [], "doc": "", "type": {"items": "string", "type":
"array"}, "name": "names"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "created"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "updated"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"default":
null, "doc": "", "type": ["null", "long"], "name": "start"},
{"default": null, "doc": "", "type": ["null", "long"], "name": "end"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"referenceBases"}, {"default": null, "doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "alternateBases"},
{"doc": "", "type": ["null", {"items": "string", "type": "array"}],
"name": "alleleIds"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name": "info"},
{"default": null, "doc": "", "type": ["null", {"items": {"doc": "",
"type": "record", "name": "Call", "fields": [{"doc": "", "type":
["null", "string"], "name": "callSetId"}, {"default": null, "doc": "",
"type": ["null", "string"], "name": "callSetName"}, {"doc": "",
"type": ["null", "string"], "name": "variantId"}, {"default": [],
"doc": "", "type": {"items": "int", "type": "array"}, "name":
"genotype"}, {"default": null, "doc": "", "type": ["null", "string",
{"items": "string", "type": "array"}], "name": "phaseset"},
{"default": [], "doc": "", "type": {"items": "double", "type":
"array"}, "name": "genotypeLikelihood"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}], "name": "calls"}],
"doc": ""}, "type": "array"}, "name": "variants"}, {"default": null,
"doc": "", "type": ["null", "string"], "name": "nextPageToken"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])
    _valueListName = "variants"

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'variants': Variant,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'nextPageToken', 'variants'
    ]

    def __init__(self):
        self.nextPageToken = None
        self.variants = []


class Segment(ProtocolElement):
    """
    A `Segment` is a range on a `Sequence`. It does not include any
    base data. (The bases for a `Sequence` are available through the
    `getSequenceBases()` API call.)  In the sequence "GTGG", the
    `Segment` starting at index 1 on the forward strand with length 2
    is the "TG" on the forward strand. The length-2 `Segment` starting
    at index 1 on the reverse strand is "AC", corresponding to the
    first two base pairs of the sequence, or the last two bases of the
    reverse complement.  A `Segment` has a left and a right end, in
    its local orientation (i.e. taking `Segment.start.strand` to be
    the `Segment`'s forward strand).
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Segment",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Side", "fields": [{"doc": "", "type": {"doc": "", "type": "record",
"name": "Position", "fields": [{"default": null, "doc": "", "type":
["null", "string"], "name": "sequenceId"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceName"}, {"doc": "",
"type": "long", "name": "position"}]}, "name": "base"}, {"doc": "",
"type": {"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type":
"enum", "name": "Strand"}, "name": "strand"}]}, "name": "start"},
{"doc": "", "type": "long", "name": "length"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "length",
        "start",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Side,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'start': Side,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'length', 'start'
    ]

    def __init__(self):
        self.length = None
        self.start = None


class Sequence(ProtocolElement):
    """
    Represents a sequence in a sequence graph. May be joined onto
    parent `Sequence`(s) at the left and/or right endpoints, and may
    have other `Sequence`s as children.  Does not include any base
    data. The bases for a `Sequence` are available through the
    `getSequenceBases()` API call.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"Sequence", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "long", "name": "length"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "id",
        "length",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'id', 'length'
    ]

    def __init__(self):
        self.id = None
        self.length = None


class Side(ProtocolElement):
    """
    A `Side` is an oriented base in some already known sequence. A
    `Side` is represented by a sequence name or ID, a base number on
    that sequence (0-based), and a `Strand` to indicate the forward or
    reverse-complement orientation.  For example, given the sequence
    "GTGG", the `Side` on that sequence at offset 1 in the forward
    orientation would be the left side of the T/A base pair. The base
    at this `Side` is "T". Alternately, for offset 1 in the reverse
    orientation, the `Side` would be the right side of the T/A base
    pair, and the base at the `Side` is "A".  Offsets added to a
    `Side` are interpreted as reading along its strand; adding to a
    reverse strand side actually subtracts from its `base.position`
    member.  There is a total ordering on sides, assuming a total
    ordering on `Sequence`s. Sides are sorted by their `Sequence` (as
    specified by `sequenceId` and/or `referenceName`), then within a
    `Sequence` by their `position` offsets, and then finally by
    `Strand`, with `NEG_STRAND` first, then `POS_STRAND`.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Side",
"fields": [{"doc": "", "type": {"doc": "", "type": "record", "name":
"Position", "fields": [{"default": null, "doc": "", "type": ["null",
"string"], "name": "sequenceId"}, {"default": null, "doc": "", "type":
["null", "string"], "name": "referenceName"}, {"doc": "", "type":
"long", "name": "position"}]}, "name": "base"}, {"doc": "", "type":
{"symbols": ["NEG_STRAND", "POS_STRAND"], "doc": "", "type": "enum",
"name": "Strand"}, "name": "strand"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "base",
        "strand",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'base': Position,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'base': Position,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'base', 'strand'
    ]

    def __init__(self):
        self.base = None
        self.strand = None


class Strand(object):
    """
    Indicates the DNA strand associate for some data item. *
    `NEG_STRAND`: The negative (-) strand. * `POS_STRAND`:  The
    postive (+) strand.
    """
    NEG_STRAND = "NEG_STRAND"
    POS_STRAND = "POS_STRAND"


class Variant(ProtocolElement):
    """
    A `Variant` represents a change in DNA sequence relative to some
    reference. For example, a variant could represent a SNP or an
    insertion. Variants belong to a `VariantSet`. This is equivalent
    to a row in VCF.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Variant",
"fields": [{"doc": "", "type": "string", "name": "id"}, {"doc": "",
"type": "string", "name": "variantSetId"}, {"default": [], "doc": "",
"type": {"items": "string", "type": "array"}, "name": "names"},
{"default": null, "doc": "", "type": ["null", "long"], "name":
"created"}, {"default": null, "doc": "", "type": ["null", "long"],
"name": "updated"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "referenceName"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "start"}, {"default": null, "doc":
"", "type": ["null", "long"], "name": "end"}, {"default": null, "doc":
"", "type": ["null", "string"], "name": "referenceBases"}, {"default":
null, "doc": "", "type": ["null", {"items": "string", "type":
"array"}], "name": "alternateBases"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "alleleIds"},
{"default": {}, "doc": "", "type": {"values": {"items": "string",
"type": "array"}, "type": "map"}, "name": "info"}, {"default": null,
"doc": "", "type": ["null", {"items": {"doc": "", "type": "record",
"name": "Call", "fields": [{"doc": "", "type": ["null", "string"],
"name": "callSetId"}, {"default": null, "doc": "", "type": ["null",
"string"], "name": "callSetName"}, {"doc": "", "type": ["null",
"string"], "name": "variantId"}, {"default": [], "doc": "", "type":
{"items": "int", "type": "array"}, "name": "genotype"}, {"default":
null, "doc": "", "type": ["null", "string", {"items": "string",
"type": "array"}], "name": "phaseset"}, {"default": [], "doc": "",
"type": {"items": "double", "type": "array"}, "name":
"genotypeLikelihood"}, {"default": {}, "doc": "", "type": {"values":
{"items": "string", "type": "array"}, "type": "map"}, "name":
"info"}]}, "type": "array"}], "name": "calls"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "alleleIds",
        "id",
        "variantSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'alleleIds', 'alternateBases', 'calls', 'created', 'end',
        'id', 'info', 'names', 'referenceBases', 'referenceName',
        'start', 'updated', 'variantSetId'
    ]

    def __init__(self):
        self.alleleIds = None
        self.alternateBases = None
        self.calls = None
        self.created = None
        self.end = None
        self.id = None
        self.info = {}
        self.names = []
        self.referenceBases = None
        self.referenceName = None
        self.start = None
        self.updated = None
        self.variantSetId = None


class VariantSet(ProtocolElement):
    """
    `Variant` and `CallSet` both belong to a `VariantSet`.
    `VariantSet` belongs to a `Dataset`. The variant set is equivalent
    to a VCF file.  A `VariantSet` can contain novel `Sequence`s,
    which are used to augment the sequence graph of its
    `ReferenceSet`, creating the augmented sequence graph against
    which `Allele`s are interpreted.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": "string", "name": "datasetId"}, {"doc": "",
"type": "string", "name": "referenceSetId"}, {"default": [], "doc":
"", "type": {"items": {"doc": "", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}]}, "type": "array"}, "name": "metadata"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "datasetId",
        "id",
        "referenceSetId",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'metadata': VariantSetMetadata,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'datasetId', 'id', 'metadata', 'referenceSetId'
    ]

    def __init__(self):
        self.datasetId = None
        self.id = None
        self.metadata = []
        self.referenceSetId = None


class VariantSetMetadata(ProtocolElement):
    """
    This metadata represents VCF header information.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"VariantSetMetadata", "fields": [{"doc": "", "type": "string", "name":
"key"}, {"doc": "", "type": "string", "name": "value"}, {"doc": "",
"type": "string", "name": "id"}, {"doc": "", "type": "string", "name":
"type"}, {"doc": "", "type": "string", "name": "number"}, {"doc": "",
"type": "string", "name": "description"}, {"default": {}, "doc": "",
"type": {"values": {"items": "string", "type": "array"}, "type":
"map"}, "name": "info"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "description",
        "id",
        "key",
        "number",
        "type",
        "value",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'description', 'id', 'info', 'key', 'number', 'type', 'value'
    ]

    def __init__(self):
        self.description = None
        self.id = None
        self.info = {}
        self.key = None
        self.number = None
        self.type = None
        self.value = None


class Wiggle(ProtocolElement):
    """
    Continuous numerical annotation along a path.
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name": "Wiggle",
"fields": [{"default": null, "doc": "", "type": ["null", "string"],
"name": "referenceName"}, {"default": null, "doc": "", "type":
["null", "long"], "name": "start"}, {"default": null, "doc": "",
"type": ["null", "long"], "name": "end"}, {"default": [], "doc": "",
"type": {"items": "float", "type": "array"}, "name": "values"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'end', 'referenceName', 'start', 'values'
    ]

    def __init__(self):
        self.end = None
        self.referenceName = None
        self.start = None
        self.values = []


class WiggleSet(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "org.ga4gh.models", "type": "record", "name":
"WiggleSet", "fields": [{"doc": "", "type": "string", "name": "id"},
{"doc": "", "type": {"doc": "", "type": "record", "name":
"Attributes", "fields": [{"default": {}, "type": {"values": {"items":
["string", {"doc": "", "type": "record", "name": "ExternalIdentifier",
"fields": [{"doc": "", "type": "string", "name": "database"}, {"doc":
"", "type": "string", "name": "identifier"}, {"doc": "", "type":
"string", "name": "version"}]}, {"doc": "", "type": "record", "name":
"OntologyTerm", "fields": [{"doc": "", "type": "string", "name":
"ontologySource"}, {"doc": "", "type": "string", "name": "id"},
{"default": null, "doc": "", "type": ["null", "string"], "name":
"name"}]}], "type": "array"}, "type": "map"}, "name": "vals"}]},
"name": "attributes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = set([
        "attributes",
        "id",
    ])

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'attributes': Attributes,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'attributes', 'id'
    ]

    def __init__(self):
        self.attributes = None
        self.id = None

postMethods = \
    [('/allelecalls/search',
      SearchAlleleCallsRequest,
      SearchVariantSetsResponse),
     ('/alleles/search',
      SearchAllelesRequest,
      SearchReadGroupSetsResponse),
     ('/analyses/search',
      SearchAnalysesRequest,
      SearchSequencesResponse),
     ('/calls/search',
      SearchCallsRequest,
      SearchSamplesResponse),
     ('/callsets/search',
      SearchCallSetsRequest,
      SearchExperimentsResponse),
     ('/datasets/search',
      SearchDatasetsRequest,
      SearchAlleleCallsResponse),
     ('/experiments/search',
      SearchExperimentsRequest,
      SearchAllelesResponse),
     ('/features/search',
      SearchFeaturesRequest,
      SearchIndividualsResponse),
     ('/individualgroups/search',
      SearchIndividualGroupsRequest,
      SearchReadsResponse),
     ('/individuals/search',
      SearchIndividualsRequest,
      SearchFeaturesResponse),
     ('/joins/search',
      SearchJoinsRequest,
      SearchIndividualGroupsResponse),
     ('/readgroupsets/search',
      SearchReadGroupSetsRequest,
      SearchCallSetsResponse),
     ('/reads/search',
      SearchReadsRequest,
      SearchJoinsResponse),
     ('/references/search',
      SearchReferencesRequest,
      SearchCallsResponse),
     ('/referencesets/search',
      SearchReferenceSetsRequest,
      SearchAnalysesResponse),
     ('/samples/search',
      SearchSamplesRequest,
      SearchReferenceSetsResponse),
     ('/sequences/search',
      SearchSequencesRequest,
      SearchDatasetsResponse),
     ('/variants/search',
      SearchVariantsRequest,
      SearchReferencesResponse),
     ('/variantsets/search',
      SearchVariantSetsRequest,
      SearchVariantsResponse)]
